"""Модуль реализующий метод Ньютона
Программа находит одно решение определённой функции
с помощью метода Ньютона в определённом интервале с определённой точностью

Автор: Черных Никита Сергеевич, КИ20-17/2б
"""
from sympy import solve, diff, SympifyError, expand, Symbol
from math import fabs


def menu():
    """Функция, реализующая меню"""

    print('Приветствую в программе, реализующей метод Ньютона!', '\n')
    while True:
        print('Меню:', '\n',
              'Выберете цифру интересующего вас варианта.', '\n',
              '1. Запуск программы', '\n',
              '2. Тестовый запуск', '\n',
              '3. Что такое метод Ньютона?', '\n',
              '4. Выход')
        message = input()
        # Запуск программы
        if message == '1':
            print('Предупреждение!', '\n',
                  'Программа не вычисляет тригонометрические и логарифмические функции', '\n',
                  'Программа не сможет реализовать метод Ньютона на кривой, которая во '
                  'введённом интервале и убывает, и возрастает', '\n',
                  'Программа считает интервал в круглых скобках, не включая крайние значения', '\n',
                  'Для избежания проблем с вычислением точности, рекомендуется вводить целочисленные'
                  'значения a и b')
            # Ввод функции, интервала, точности
            try:
                print('Введите функцию')
                y = input()
                print('Введите интервал')
                print('Введите крайнее левое значение интервала')
                a = input()
                print('Введите крайнее правое значение интервала')
                b = input()
                print('Введите точность')
                e = float(input())
            except ValueError:
                print('Ошибка при вводе')
                data = 'False'
            else:
                data = check(y, a, b, e)
            if data == 'False':
                print('Некорректный ввод', '\n')
            else:
                iteration(data)
        # Тестовый ввод заранее определённой функции
        elif message == '2':
            print('Задан функция x**2-4 c интервалом (0, 5) и точность 0.001')
            x = Symbol('x')
            # функция, производная, решение, интервал, точность
            data = 'x**2-4', diff(x**2-4), '2', 2, '0', '5', 0.001
            iteration(data)
        # Объяснения метода Ньютона
        elif message == '3':
            print('Метод Ньютона заключается в том, что находится '
                  'примерный интервал, в котором функция точно имеет', '\n'
                  'решение(пересекает ось Ox).После нахождения '
                  'примерного интервала, берутся производные первого ', '\n'
                  'и второго порядка. После этого, в зависимости от рода '
                  'функции, берётся точка на одном из концов заданного ', '\n'
                  'интервала и через неё проводят касательную, получая '
                  'примерное значение функции. Затем строится '
                  'перпендикуляр ', '\n', 'от точки пересечения '
                  'касательной и оси Ox к функции.' 'Это первая итерация.'
                  ' Итерации повторяются до тех пор,', '\n'
                  'пока длина отрезка не будет равна e(точность).', '\n')
        # Выход из программы
        elif message == '4':
            break


def check(y, a, b, e):
    """ Функция выискивает ошибки во введённых пользователем данных и
    собирает данные о функции f(x)
    :keyword
    y - функция, введённая пользователем
    a, b - левый и правый границы интервала
    e - точность

    :return
    y - функция, введённая пользователем
    y_ - первая производная функции
    y__ - вторая производная функции
    x0 - решение уравнения/точка пересечения функции и оси абсцисс
    a, b - левый и правый границы интервала
    e - точность
    'False' - Неверные значения
    'False lit' - Отсутствие решения

    :exception
    SyntaxError - исключение при некорректном вводе функции
    SympifyError - исключение при работе с Sympy
    TypeError - исключение при вводе не тех типов данных
    ValueError - исключение при вводе некорректного значения
    """

    """    
    >>> check('x**2-4', 0, 5, 0.001)
    ('x**2-4', 2*x, 2, 2, 0, 5, 0.001)
    
    >>> check('x**3-1', 0, 10, 0.001)
    ('x**3-1', 3*x**2, 6*x, 1, 0, 10, 0.001)
    
    >>> check('hello', 3, 2, 1)
    'False'
    """
    try:
        if float(a) < float(b) and 0.001 <= e <= 0.1:
            # Вычисление производных первого и второго рода
            y_ = diff(y)
            y__ = diff(y_)
            # Нахождение корня
            x0 = solve(y)
            # Проверка на принадлежность корня к промежутку
            for i in range(len(x0)):
                if int(x0[i]) in range(int(a), int(b)):
                    # Выбор одного корня, так как метод не рассматривает
                    # множество решений
                    x0 = x0[i]
                    return y, y_, y__, x0, a, b, e
            return 'False lit'
        else:
            return 'False'
    except SyntaxError:
        return 'False'
    except SympifyError:
        return 'False'
    except TypeError:
        return 'False'
    except ValueError:
        return 'False'


def iteration(data):
    """Функция для реализации метода Ньютона

    :keyword
    data - вся информация о функции f(x) из функции check

    :return
    'False' - если метод Ньютона не применим к данной функции

    :exception
    TypeError - исключение при вычислении значений
    """

    """
    >>> x = Symbol('x')
    >>> data = 'x**2-4', 2*x, 2, 2, 0, 5, 0.001
    >>> iteration(data)
    С учётом точности, наиближайшим решением будет: 2.0000081488992834
    
    >>> x = Symbol('x')
    >>> data = 'x-4', 1, 0, 4, 0, 5, 0.001
    >>> iteration(data)
    Построение касательной невозможно
    'False' 
    
    """
    # счётчик ошибок
    bad = 0
    y, y_, y__, x0, a, b, e = data
    # Сохранение исходных функций
    y_orig = y
    y__orig = y_
    # Вычисление значений функций
    # a+0.001 сделано для того, чтобы значение рассматривалось в
    # границах интервала, а не на границах
    try:
        a = int(a)
        y = switching(y, a + 0.0001)
        y_ = switching(y_, a + 0.0001)
        y__ = switching(y__, a + 0.0001)
    except TypeError:
        print('Некорректный ввод')
    except SyntaxError:
        print('Некорректный ввод')
    else:
        # Проверка возрастания/убывания и выпуклости/вогнутости
        # x_koren - это точка пересечения касательной и оси Ox
        if (y_ > 0 and y__ > 0) or (y_ < 0 and y__ < 0):
            x_koren = int(b)
        elif (y_ > 0 and y__ < 0) or (y_ < 0 and y__ > 0):
            x_koren = int(a)
        else:
            # Если y_ или y__ равны 0, то построить касательную невозможно
            bad = 1
            x_koren = 0
            print('Построение касательной невозможно')

        if not bad == 1:
            # Реализация формулы метода Ньютона и последующих итераций
            try:
                while fabs(x_koren - x0) > e:
                    x1 = x_koren - y/y_
                    x_koren = x1
                    y = switching(y_orig, x_koren)
                    y_ = switching(str(y__orig), x_koren)
                print('С учётом точности, наиближайшим решением будет:',
                      x_koren, '\n')
            except TypeError:
                print('Задан промежуток, где функция и убывает, и'
                      ' возрастает.', '\n')
        else:
            return 'False'


def switching(y, a):
    """Функция для вычисления функции y(a)
    :keyword
    y - функция
    a - значение, от которого находится функция

    :return
    new_y - значение функции y(a)
    """

    """
    >>> switching('x**2-4', 3)
    5.0
    
    >>> switching('hello', 2)
    Traceback (most recent call last):
        ...
    TypeError: can't convert expression to float
    
    >>> switching('x**2+75', -7)
    124.0
    """
    # Перевод типа str в тип list, замена переменной в выражении на число,
    # вычисление значения функции от заданного числа
    useless_list = ''
    y = str(y)
    y = list(y)
    for i in range(len(y)):
        if y[i] == 'x':
            y[i] = '('+str(a)+')'
        useless_list = useless_list + y[i]
    new_y = useless_list
    new_y = float(expand(new_y))
    return new_y


if __name__ == '__main__':
    import doctest
    doctest.testmod()
    menu()

